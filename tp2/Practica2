
ALUMNOS: Ait, Ismael  ; Pajón, Manuel ; Postan, Ezequiel

        #############################################################################################

                                        Introducción a NACHOS


                Responda a las siguientes preguntas en base al código de NACHOS.

        #############################################################################################

   1. ¿Cuánta memoria tiene la máquina simulada para NACHOS?

En disk.h se define  SectorSize = 128 que representa la cantidad de bytes por sector de disco.
Luego en machine.h se define
const int PageSize = SectorSize;        // set the page size equal to
                                        // the disk sector size, for
                                        // simplicity

const int NumPhysPages = 32;
const int MemorySize = NumPhysPages * PageSize;

En machine.cc:
    mainMemory = new char[MemorySize];

Por lo tanto la memoria es de 4096 bytes = 4Kb

        #############################################################################################

2. ¿Cómo cambiaría ese valor?

        Aumentando el número de páginas físicas (cambiando el valor de NumPhysPages definido en machine.h)

        #############################################################################################

3. ¿De qué tamaño es un disco?

Definido en disk.h:
        const int SectorSize = 128;     // number of bytes per disk sector
        const int SectorsPerTrack = 32; // number of sectors per disk track 
        const int NumTracks = 32;       // number of tracks per disk
        const int NumSectors = SectorsPerTrack * NumTracks;
        
Definido en disk.cc:
        #define MagicNumber     0x456789ab
        #define MagicSize       sizeof(int)
        
        #define DiskSize        (MagicSize + (NumSectors * SectorSize))

Concluimos que: 
El tamaño del archivo que contiene al disco es de sizeof(int) + 1024*128 = 131072 + sizeof(int) bytes que es 
+o- 131076 bytes

El sizeof int no es parte del disco, sino que es un número de identificación del archivo. Por lo que el 
disco tiene 131072 bytes = 128 KB
 
        #############################################################################################

4. ¿Cuántas instrucciones del MIPS simula NACHOS?

        En mipssim.h se definen 61 opcode de mips
        Se ejecutan las que se especifican en el switch de machine/mipssim.cc.


        #############################################################################################

5. Explicar el código que procesa la instrucción ''add''

Extraído de mipssim.cc:

      case OP_ADD:
        sum = registers[(int)instr->rs] + registers[(int)instr->rt];
        if (!((registers[(int)instr->rs] ^ registers[(int)instr->rt]) & SIGN_BIT) &&
            ((registers[(int)instr->rs] ^ sum) & SIGN_BIT)) {
            RaiseException(OverflowException, 0);
            return;
        }
        registers[(int)instr->rd] = sum;
        break;

        Los operandos están en register[instr->rs] y register[instr->rt]. 
        Se suman los operandos y se guardan en sum
        La primera parte de la  guarda del if comprueba si los operandos tienen el mismo signo. 
        Si tienen distinto signo es imposible que haya overflow. 
        Si tienen igual signo pasan a la segunda parte de la guarda.
        La segunda condición comprueba que la suma no haya cambiado de signo. De haber ocurrido esto hubo 
        overflow y ejecuta un excepción.

        ############################################################################################

6. Nombrar los archivos fuente en los que figuran las funciones y métodos llamados por el main de NACHOS al 
ejecutarlo en el directorio threads (hasta dos niveles de profundidad).

+-----------------------------+--------------------------+----------+------------------------------------+
|       FUNCIÓN/MÉTODO        | ARCHIVO EN QUE SE DEFINE | LLAMANTE |            DESCRIPCIÓN             |
+-----------------------------+--------------------------+----------+------------------------------------+
| DEBUG('t', "Entering main") |    threads/utility.cc    |   main   |Imprime mensajes de debug según las |
|                             |                          |          |          banderas setteadas        |
+-----------------------------+--------------------------+----------+------------------------------------+
|    DebugIsEnabled(flag)     |    threads/utility.cc    |  DEBUG   |Verifica si se han setteado flags de|
|                             |                          |          |               debug                |
+-----------------------------+--------------------------+----------+------------------------------------+
|   Initialize(argc, argv);   |     threads/system.cc    |   main   |                                    |
+-----------------------------+--------------------------+----------+------------------------------------+
|RandomInit(atoi(*(argv+1))); |     machine/sysdep.cc    |Initialize|   Inicializa generador de números  |
|                             |                          |          |    aleatorios (equivale a srand)   |
+-----------------------------+--------------------------+----------+------------------------------------+
|    DebugInit(debugArgs);    |    threads/utility.cc    |Initialize|      Setea las flags de DEBUG      | 
|                             |                          |          |                                    |
+-----------------------------+--------------------------+----------+------------------------------------+
|   stats = new Statistics(); |     machine/stats.cc     |Initialize|  Constructor de clase. Recolecta   |
|                             |                          |          | estadísticas (escrit de disco, etc)|
+-----------------------------+--------------------------+----------+------------------------------------+
|  interrupt = new Interrupt; |   machine/interrupt.cc   |Initialize|    start up interrupt handling     |
+-----------------------------+--------------------------+----------+------------------------------------+
| scheduler = new Scheduler();|   threads/scheduler.cc   |Initialize|  Initialize the list of ready but  |
|                             |                          |          |    not running threads to empty.   |
+-----------------------------+--------------------------+----------+------------------------------------+
| timer = new                 |                          |          |Initialize a hardware timer device. |
| Timer(TimerInterruptHandler,|     machine/timer.cc     |Initialize|Save the place to call on each      |
| 0, randomYield);            |                          |          |interrupt, and then arrange for the |
|                             |                          |          |timer to start generating interrupts|
+-----------------------------+--------------------------+----------+------------------------------------+
|    new Thread("main");      |    threads/thread.cc     |Initialize|Initialize a thread control block,so|
|                             |                          |          |that we can then call Thread::Fork  |
+-----------------------------+--------------------------+----------+------------------------------------+
|currentThread->              |   machine/interrupt.h    |Initialize|       Setea estado del proceso     |
|        setStatus(RUNNING);  |                          |          |                                    |
+-----------------------------+--------------------------+----------+------------------------------------+
|    interrupt->Enable();     |   machine/interrupt.cc   |Initialize|     Activa las interrupciones      |
+-----------------------------+--------------------------+----------+------------------------------------+
|  CallOnUserAbort(Cleanup);  |     machine/sysdep.cc    |Initialize|  Llama a Cleanup si pulsan  Ctl+C  |
+-----------------------------+--------------------------+----------+------------------------------------+
| preemptiveScheduler =       |                          |          | Set up time slicing between kernel |
|  new PreemptiveScheduler(); |   threads/preemptive.h   |Initialize| threads, el constructor está vacío |
|                             |                          |          | la clase entera es la función SetUp|
+-----------------------------+--------------------------+----------+------------------------------------+
|                             |                          |          |  Set up the preemptive scheduler   |
| preemptiveScheduler->       |                          |          |   The 'timeSliceLength' argument   |
|       SetUp(timeSlice);     |  threads/preemptive.cc   |Initialize|       means how many machine       |
|                             |                          |          |   instructions will last the time  |
|                             |                          |          |    slice for every kernel thread   |
+-----------------------------+--------------------------+----------+------------------------------------+
|        ThreadTest();        |  threads/threadtest.cc   |   main   |      Crea threads de prueba        |
+-----------------------------+--------------------------+----------+------------------------------------+
|  DEBUG('t',                 |   threads/utility.cc     |ThreadTest|       Comantada anteriormente      |
|     "Entering SimpleTest"); |                          |          |                                    |
+-----------------------------+--------------------------+----------+------------------------------------+
| Thread* newThread =         |    threads/thread.cc     |ThreadTest|       Comantada anteriormente      |
|   new Thread (threadname);  |                          |          |                                    |
+-----------------------------+--------------------------+----------+------------------------------------+
|   newThread->Fork           |                          |          |                                    |
|    (SimpleThread,           |    threads/thread.cc     |ThreadTest|              --------              |
|   (void*)threadname);       |                          |          |                                    |
+-----------------------------+--------------------------+----------+------------------------------------+
|SimpleThread((void*)"Hilo 0")|  threads/threadtest.cc   |ThreadTest| Loop 10 times, yielding the CPU to |
|                             |                          |          |another ready thread each iteration.|
+-----------------------------+--------------------------+----------+------------------------------------+
|                             |                          |          |    Pone en cola el hilo para ser   |
|  currentThread->Finish();   |    threads/thread.cc     |   main   |              destruido             |
|                             |                          |          |                                    |
+-----------------------------+--------------------------+----------+------------------------------------+
|                             |                          | current  | Change interrupts to be enabled or |
| interrupt->SetLevel(IntOff);|   machine/interrupt.cc   | Thread-> |   disabled, and if interrupts are  |
|                             |                          | Finish();|  being enabled, advance simulated  |
|                             |                          |          |      time by calling OneTick().    |
+-----------------------------+--------------------------+----------+------------------------------------+
|                             |                          | current  |                                    |
|         getName();          |    threads/thread.h      | Thread-> |    Devuelve el nombre del hilo     |
|                             |                          | Finish();|                                    |
+-----------------------------+--------------------------+----------+------------------------------------+
|                             |                          |          |  Relinquish the CPU, because the   |
|                             |                          |          | current thread is blocked waiting  |
|                             |                          | current  |   on a synchronization variable    |
|          Sleep();           |    threads/thread.cc     | Thread-> |  (Semaphore, Lock, or Condition).  |
|                             |                          | Finish();| Eventually, some thread will wake  |
|                             |                          |          | this thread up, and put it back on |
|                             |                          |          |   the ready queue, so that it can  |
|                             |                          |          |           be re-scheduled.         |
+-----------------------------+--------------------------+----------+------------------------------------+

        
        #############################################################################################

7. ¿Porqué se prefiere emular una CPU en vez de utilizar directamente la CPU existente?

        - Para poder usar los debuggers.
        - Para poder adaptarlo fácilmente a los recusos de la máquina disponible.
        
        #############################################################################################

8. Probar el efecto de las distintas banderas de debug.


Hemos probado: 

//      The debugging routines allow the user to turn on selected
//      debugging messages, controllable from the command line arguments
//      passed to Nachos (-d).  You are encouraged to add your own
//      debugging flags.  The pre-defined debugging flags are:
//
//      '+' -- turn on all debug messages
//      't' -- thread system
//      's' -- semaphores, locks, and conditions
//      'i' -- interrupt emulation
//      'm' -- machine emulation (USER_PROGRAM)
//      'd' -- disk emulation (FILESYS)
//      'f' -- file system (FILESYS)
//      'a' -- address spaces (USER_PROGRAM)
//      'n' -- network emulation (NETWORK)


        #############################################################################################


   9. ¿Qué efecto hacen las macros ASSERT y DEBUG definidas en ''utility.h''?

//----------------------------------------------------------------------
// ASSERT
//      If condition is false,  print a message and dump core.
//      Useful for documenting assumptions in the code.
//
//      NOTE: needs to be a #define, to be able to print the location 
//      where the error occurred.
//----------------------------------------------------------------------
#define ASSERT(condition)                                                     \
    if (!(condition)) {                                                       \
        fprintf(stderr, "Assertion failed: line %d, file \"%s\"\n",           \
                __LINE__, __FILE__);                                          \
        fflush(stderr);                                                       \
        Abort();                                                              \
    }

Si la condición pasada a ASSERT es distinta de 0 entonces todo sigue su curso normal
Si la condición es falsa, termina el programa e imprime un emnsaje de error.
Se usa para verificar que se cumplen ciertas condiciones en distintas partes del programa.




De utility.cc:

//----------------------------------------------------------------------
// DEBUG
//      Print a debug message, if flag is enabled.  Like printf,
//      only with an extra argument on the front.
//----------------------------------------------------------------------

void
DEBUG(char flag, const char *format, ...)
{
    if (DebugIsEnabled(flag)) {
        va_list ap;
        // You will get an unused variable message here -- ignore it.
        va_start(ap, format);
        vfprintf(stdout, format, ap);
        va_end(ap);
        fflush(stdout);
    }
}

DEBUG imprime mensajes dependiendo de las banderas activadas al iniciar nachos.
Como lo dice el comentario del código es un printf condicionado a la bandera 
que se le pasa como primer argumento.

        #############################################################################################

  10. ¿Dónde están definidas las constantes USER_PROGRAM, FILESYS_NEEDED, FILESYS_STUB y NETWORK?

        Se definen en tiempo de compilación por medio de los siguientes Makefiles

        - USER_PROGRAM:
                filesys/Makefile
                network/Makefile
                userprog/Makefile
                vm/Makefile
        
        - FILESYS_NEEDED     
                filesys/Makefile
                network/Makefile
                userprog/Makefile
                vm/Makefile

        - FILESYS_STUB 
                userprog/Makefile
                vm/Makefile

        - NETWORK
                network/Makefile


        #############################################################################################

  11. ¿Cuál es la diferencia entre las clases ''list'' y ''synchlist''?

La diferencia es que synchlist tiene implementadas condiciones de concurrencia. Por ejemplo:
- Para borrar un elemento de la lista espera hasta que haya uno.
- La synchlist posse un lock y una variable de condición
 

        #############################################################################################

  12. ¿En qué archivos está definida la función ''main''? ¿en qué archivo está definida la función ''main'' 
del ejecutable ''nachos'' del directorio ''userprog''?

        Está definida en /threads/main.cc y según el Makefile que lo compile, compilará un código u otro

        #############################################################################################

  13. ¿Qué línea de comandos soporta NACHOS? ¿qué efecto hace la opción ''-rs''?

Del archivo main.cc:

// Usage: nachos -d <debugflags> -rs <random seed #>
//              -s -x <nachos file> -c <consoleIn> <consoleOut>
//              -f -cp <unix file> <nachos file>
//              -p <nachos file> -r <nachos file> -l -D -t
//              -n <network reliability> -m <machine id>
//              -o <other machine id>
//              -z
//
//    -d causes certain debugging messages to be printed (cf. utility.h)
//    -rs causes Yield to occur at random (but repeatable) spots
//    -z prints the copyright message
//
//  USER_PROGRAM
//    -s causes user programs to be executed in single-step mode
//    -x runs a user program
//    -c tests the console
//
//  FILESYS
//    -f causes the physical disk to be formatted
//    -cp copies a file from UNIX to Nachos
//    -p prints a Nachos file to stdout
//    -r removes a Nachos file from the file system
//    -l lists the contents of the Nachos directory
//    -D prints the contents of the entire file system 
//    -t tests the performance of the Nachos file system
//
//  NETWORK
//    -n sets the network reliability
//    -m sets this machine's host id (needed for the network)
//    -o runs a simple test of the Nachos network software

La opción '-rs' hace que se al crearse el timer en la función Initialize, se cree con tercer argumento igual a True.
Esto hace que las interrupciones ocurran de manera aleatoria.

        #############################################################################################

  14. Modificar el ejemplo del directorio threads para que se generen 5 threads en lugar de 2.

        En primer lugar, genera 11 threads, no 2 :P 
        Para resolver el ejercicio, modificamos la función 
        
void
ThreadTest()
{
    DEBUG('t', "Entering SimpleTest");

    for ( int k=1; k<=10; k++) {
      char* threadname = new char[100];
      sprintf(threadname, "Hilo %d", k);
      Thread* newThread = new Thread (threadname);
      newThread->Fork (SimpleThread, (void*)threadname);
    }

    SimpleThread( (void*)"Hilo 0");
}

del archivo threads/threadtest.cc por la siguiente

void
ThreadTest()
{
    DEBUG('t', "Entering SimpleTest");

    for ( int k=1; k<=4; k++) {
      char* threadname = new char[100];
      sprintf(threadname, "Hilo %d", k);
      Thread* newThread = new Thread (threadname);
      newThread->Fork (SimpleThread, (void*)threadname);
    }

    SimpleThread( (void*)"Hilo 0");
}

(Cambiamos la cota de k<=10 por  k<=4)
